class ScheduleEngine{constructor(){this.scheduleData=null;this.lockedBlocks=new Set();this.loadSchedule();}
async loadSchedule(){try{const savedSchedule=localStorage.getItem("lifeOS_v2_schedule");if(savedSchedule){this.scheduleData=JSON.parse(savedSchedule);}else{const response=await fetch("./core/scheduleData.json");if(response.ok){this.scheduleData=await response.json();this.saveSchedule();}else{console.error("Failed to load schedule data");this.scheduleData={};}}}catch(error){console.error("Error loading schedule:",error);this.scheduleData={};}}
saveSchedule(){try{localStorage.setItem("lifeOS_v2_schedule",JSON.stringify(this.scheduleData));}catch(error){console.error("Error saving schedule:",error);}}
getScheduleForDate(date){const dayOfWeek=date.getDay().toString();const baseSchedule=this.scheduleData[dayOfWeek]||[];return JSON.parse(JSON.stringify(baseSchedule));}
updateTask(dayOfWeek,taskId,updates){if(!this.scheduleData[dayOfWeek])return false;const taskIndex=this.scheduleData[dayOfWeek].findIndex((task)=>task.id===taskId);if(taskIndex===-1)return false;if(this.lockedBlocks.has(taskId)){console.warn("Cannot update locked task:",taskId);return false;}
Object.assign(this.scheduleData[dayOfWeek][taskIndex],updates);this.saveSchedule();return true;}
addTask(dayOfWeek,task){if(!this.scheduleData[dayOfWeek]){this.scheduleData[dayOfWeek]=[];}
if(!task.id){task.id=`${dayOfWeek}_${Date.now()}`;}
this.scheduleData[dayOfWeek].push(task);this.saveSchedule();return task.id;}
removeTask(dayOfWeek,taskId){if(!this.scheduleData[dayOfWeek])return false;if(this.lockedBlocks.has(taskId)){console.warn("Cannot remove locked task:",taskId);return false;}
const taskIndex=this.scheduleData[dayOfWeek].findIndex((task)=>task.id===taskId);if(taskIndex===-1)return false;this.scheduleData[dayOfWeek].splice(taskIndex,1);this.saveSchedule();return true;}
lockTask(taskId){this.lockedBlocks.add(taskId);}
unlockTask(taskId){this.lockedBlocks.delete(taskId);}
isTaskLocked(taskId){return this.lockedBlocks.has(taskId);}
getTasksByCategory(category){const tasks=[];for(let day=0;day<7;day++){const dayTasks=this.scheduleData[day.toString()]||[];tasks.push(...dayTasks.filter((task)=>task.category===category));}
return tasks;}
getWeeklyOverview(){const overview={};for(let day=0;day<7;day++){const dayStr=day.toString();overview[dayStr]={tasks:this.scheduleData[dayStr]||[],totalXP:(this.scheduleData[dayStr]||[]).reduce((sum,task)=>sum+(task.baseXP||0),0),categories:[...new Set((this.scheduleData[dayStr]||[]).map((task)=>task.category)),],};}
return overview;}
async resetToDefault(){try{const response=await fetch("./core/scheduleData.json");if(response.ok){this.scheduleData=await response.json();this.lockedBlocks.clear();this.saveSchedule();return true;}}catch(error){console.error("Error resetting schedule:",error);}
return false;}
exportSchedule(){return JSON.stringify(this.scheduleData,null,2);}
importSchedule(jsonString){try{const newSchedule=JSON.parse(jsonString);if(typeof newSchedule==="object"&&newSchedule!==null){this.scheduleData=newSchedule;this.saveSchedule();return true;}}catch(error){console.error("Error importing schedule:",error);}
return false;}}
export const scheduleEngine=new ScheduleEngine();